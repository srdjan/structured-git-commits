{"prompt_id":"p01_hook_retry_tradeoff","prompt":"Why did we avoid retrying local LLM calls inside hooks, and what reliability strategy replaced retries?","commit_labels":[{"hash":"f5203976555d9057e37469f2eaec0af1570e6a6d","relevance":3},{"hash":"f0854f10263399c6072347aa3020e203d513fb0d","relevance":2}],"must_include_hashes":["f5203976555d9057e37469f2eaec0af1570e6a6d"],"gold_facts":["LLM retries in hooks were rejected because retries would double latency.","Hook behavior is fail-open and should not block the user on errors.","When Ollama fails, the system falls back to keyword/heuristic paths rather than retrying in-hook."]}
{"prompt_id":"p02_retrofit_alternatives","prompt":"For retrofit commit rewriting, which approaches were rejected and why?","commit_labels":[{"hash":"562d5fd1a41e2691a3b6642a41116e8cab7b7d80","relevance":3},{"hash":"1f2e4c8c5ff529094a7c3634cedc4175301f4439","relevance":1}],"must_include_hashes":["562d5fd1a41e2691a3b6642a41116e8cab7b7d80"],"gold_facts":["Retrofit rejected git rebase --exec because it is interactive and harder to automate.","Retrofit rejected per-commit amend loops due to O(n^2) rebase overhead.","Apply mode uses a filter-branch based rewrite path after validation."]}
{"prompt_id":"p03_query_precision_regressions","prompt":"What exact precision fixes were made in query filtering for scope, decided-against matching, and multi-intent behavior?","commit_labels":[{"hash":"ee2a4ee937c8e4a062627ae212630eae2d9bc3de","relevance":3},{"hash":"c59b6b491a4afb95fa0190652c19793c90ade424","relevance":1}],"must_include_hashes":["ee2a4ee937c8e4a062627ae212630eae2d9bc3de"],"gold_facts":["Scope matching was changed from substring to hierarchical prefix matching.","Decided-against matching was changed from substring to word-boundary matching.","Multi-intent filtering was changed to OR-union semantics across intent keys."]}
{"prompt_id":"p04_path_query_perf","prompt":"How did we accelerate path-based history queries, and what Bloom filter implementation choice was explicitly rejected?","commit_labels":[{"hash":"0f457a225390317dd5ebbbf52b76dde1afcb85b8","relevance":3},{"hash":"fe0522aa6b2b39e20e63cdaeb5ec78d339a1a468","relevance":2}],"must_include_hashes":["0f457a225390317dd5ebbbf52b76dde1afcb85b8"],"gold_facts":["The project added commit-graph maintenance with changed-paths Bloom filter support.","Manual Bloom filter implementation was rejected in favor of native git support.","The change targeted faster path-constrained history operations and ancestry checks."]}
{"prompt_id":"p05_userpromptsubmit_history","prompt":"When auto context injection was first added, what design constraints were documented around prompt-aware filtering and stale indexes?","commit_labels":[{"hash":"f0854f10263399c6072347aa3020e203d513fb0d","relevance":3},{"hash":"f5203976555d9057e37469f2eaec0af1570e6a6d","relevance":2}],"must_include_hashes":["f0854f10263399c6072347aa3020e203d513fb0d"],"gold_facts":["The initial hook commit rejected prompt-aware filtering as too much latency/complexity.","It also rejected rebuilding stale indexes inside the hook due to unpredictable latency.","The hook was designed to inject context automatically before prompts."]}
{"prompt_id":"p06_two_skill_split","prompt":"Why was the repository split into two skills, and which alternatives were rejected?","commit_labels":[{"hash":"d97fd1b38914e639dadf87ca5cd9762c4fe6d862","relevance":3},{"hash":"c546aa171b58e71f8daa5eb1f768cce47d0d81c7","relevance":2}],"must_include_hashes":["d97fd1b38914e639dadf87ca5cd9762c4fe6d862"],"gold_facts":["The repo was restructured so one skill writes structured commits and another teaches querying history.","A single-skill approach with examples was rejected as insufficient proactive guidance.","A separate repository for query skill was rejected to preserve pairing of write and read workflows."]}
{"prompt_id":"p07_skill_renames","prompt":"What naming convention changes were made for skills, and what inconsistency were we avoiding?","commit_labels":[{"hash":"c546aa171b58e71f8daa5eb1f768cce47d0d81c7","relevance":3},{"hash":"d97fd1b38914e639dadf87ca5cd9762c4fe6d862","relevance":1}],"must_include_hashes":["c546aa171b58e71f8daa5eb1f768cce47d0d81c7"],"gold_facts":["Skills were renamed to git-structure-commits and git-query-commits.","The change standardized git- prefixed naming for consistency.","Mixed naming was explicitly rejected as inconsistent."]}
{"prompt_id":"p08_rlm_docs_shift","prompt":"Which commit elevated RLM terminology across docs, and what content strategy was chosen instead of full rewrite?","commit_labels":[{"hash":"cf428e0791a5cebeedc1ffd2b11e479184ba08fe","relevance":3},{"hash":"a338c151bd7bfb0b27003daf1ede5e765db0a463","relevance":2},{"hash":"cdf2578762d81ac208c13711b369abbb09ecc536","relevance":1}],"must_include_hashes":["cf428e0791a5cebeedc1ffd2b11e479184ba08fe"],"gold_facts":["The docs shifted terminology from Read-Log-Memory to RLM.","README gained an RLM pattern section with paper citation and mapping.","A full rewrite was rejected in favor of restructuring existing prose."]}
{"prompt_id":"p09_install_script","prompt":"How does rlm:install modify a target project, and what operational safeguards are built in?","commit_labels":[{"hash":"0845eebcfe1984b7825ad57774ecf21ed8b68b32","relevance":3},{"hash":"cdf2578762d81ac208c13711b369abbb09ecc536","relevance":2},{"hash":"cf428e0791a5cebeedc1ffd2b11e479184ba08fe","relevance":1}],"must_include_hashes":["0845eebcfe1984b7825ad57774ecf21ed8b68b32"],"gold_facts":["rlm:install copies scripts, merges hooks, injects CLAUDE sections, and adds deno tasks.","The installer is idempotent.","It supports dry-run, uninstall, and skip-hooks modes."]}
{"prompt_id":"p10_llm_capabilities","prompt":"What extra capabilities does local LLM mode add beyond keyword matching, and what fallback behavior exists?","commit_labels":[{"hash":"f5203976555d9057e37469f2eaec0af1570e6a6d","relevance":3},{"hash":"cf428e0791a5cebeedc1ffd2b11e479184ba08fe","relevance":1}],"must_include_hashes":["f5203976555d9057e37469f2eaec0af1570e6a6d"],"gold_facts":["Local LLM mode adds prompt analysis, recursive follow-up query generation, and context summarization.","If local LLM calls fail, the system falls back to non-LLM retrieval paths.","The local client intentionally uses a lightweight raw fetch approach instead of an SDK dependency."]}
{"prompt_id":"p11_negative_control","prompt":"What decisions have we recorded about database sharding and cross-region replication in this repo?","commit_labels":[],"must_include_hashes":[],"gold_facts":["The available commit history has no direct structured decisions about database sharding in this repository."]}
